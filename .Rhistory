plot(periodogram((do5_filtrado, main="Periodogram DO5 Filtrado")))
plot(periodogram(do5_filtrado, main="Periodogram DO5 Filtrado"))
do5_filtrado_per <- periodogram(do5_filtrado, main="Periodogram DO5 Filtrado")
do5_filtrado_per
library("stats")
do5_pgram <- spec.pgram(do5_filtrado)
do5_pgram <- spec.pgram(do5_filtrado_per)
do5_pgram <- spec.pgram(do5)
dfDo5 <- as.data.frame(do5_per)
do5_spec <- spec(do5)
do5
do5.downsamped <- downsample(do5, samp.rate =24000)
do5_spec <- spec(do5.downsamped)
dfDo5 <- as.data.frame(frecuencia=do5_spec$freq)
dfDo5
do5_spec
plot(do5_spec)
dfDo5 <- as.data.frame(frecuencia=do5_spec$freq, densidad=do5_spec$spec)
dfDo5 <- as.data.frame(do5_spec)
dfDo5
max(dfDo5)
min(dfDo5)
library("seewave")
#AUDIOS NUESTROS BANDA DE BARK 8000 a 9200 -> aplicamos periodogram y obtenemos la frecuencia
#De aparición de cada frecuencia de ruido, (aplicamos un arbol de huffman en eso)
#Agregar al final la códificicación
guitar_bark <- ffilter(guitar_bark, from=8000, to=9200, bandpass=TRUE, output="Wave")
#AUDIOS NUESTROS BANDA DE BARK 8000 a 9200 -> aplicamos periodogram y obtenemos la frecuencia
#De aparición de cada frecuencia de ruido, (aplicamos un arbol de huffman en eso)
#Agregar al final la códificicación
guitar_bark <- ffilter(guitar, from=8000, to=9200, bandpass=TRUE, output="Wave")
#AUDIOS NUESTROS BANDA DE BARK 8000 a 9200 -> aplicamos periodogram y obtenemos la frecuencia
#De aparición de cada frecuencia de ruido, (aplicamos un arbol de huffman en eso)
#Agregar al final la códificicación
guitar_bark <- ffilter(guitarra, from=8000, to=9200, bandpass=TRUE, output="Wave")
guitar_bark
guitar_bark_per <- periodogram(guitar_bark, main="Periodogram Guitarra Bark")
plot(guitar_bark_per)
plot(guitar_per)
plot(guitar_per, title="Periodogram Guitarra")
plot(guitar_per, main="Periodogram Guitarra")
plot(guitar_bark_per, main="Periodogram Guitarra Bark")
#AUDIOS NUESTROS BANDA DE BARK 8000 a 9200 -> aplicamos periodogram y obtenemos la frecuencia
#De aparición de cada frecuencia de ruido, (aplicamos un arbol de huffman en eso)
#Agregar al final la códificicación
guitar_bark <- ffilter(guitarra, from=8000, to=9200, bandpass=TRUE, output="Wave")
guitar_bark_per <- periodogram(guitar_bark)
plot(guitar_per, main="Periodogram Guitarra")
plot(guitar_bark_per, main="Periodogram Guitarra Bark")
derrape_bark <- ffilter(derrape, from=8000, to=9200, bandpass=TRUE, output="Wave")
derrape_bark_per <- periodogram(derrape_bark, main="Periodogram Derrape")
plot(derrape_bark_per, main="Periodogram Derrape")
test_df <- as.data.frame.matrix(derrape_bark_per)
df <- data.frame(derrape_bark_per)
test_p <- periodogram(derrape_bark, plot=FALSE)
df <- data.frame(derrape_bark_per)
test_p
test_p <- periodogram(derrape_bark, plot=FALSE)
derrape_bark
test_p <- periodogram(derrape_bark, plot=FALSE)
df <- as.data.frame(derrape_bark_per)
p<- derrape_bark_per
df <- as.data.frame(cbind(freq = p$freq, spec = p$spec))
p
df <- data.frame(frequency = p@freq, amplitude = p@amp)
df <- data.frame(frequency = p@freq, normalize = p@normalize)
plot(df)
df
oscillo(derrape, main="Oscillo Derrape")
#analizar relacion de spec con oscilo y periodogram
library("seewave")
oscillo(derrape, main="Oscillo Derrape")
oscillo(derrape, name="Oscillo Derrape")
oscillo(derrape, title="Oscillo Derrape")
derrape.per <- periodogram(derrape)
plot(derrape.per)
spec(derrape)
#analizar relacion de spec con oscilo y periodogram
library("seewave")
oscillo(derrape, title="Oscillo Derrape") #Amplitud vs Tiempo
derrape.spec <- spec(derrape) #Amplitud vs Frecuencia
#Documentación de seewave: fpeaks.
#Aparentemente fpeaks puede llegar a consumir muchos recursos, para solucionar eso.
#Se baja el sample rate, pero con el cuidado de tener en cuenta las frecuencias
#presentes en el audio.
derrape.fpeaks <- fpeaks(derrape.spec)
plot(derrape.fpeaks)
derrape
derrape.fpeaks
#Documentación de seewave: fpeaks.
#Aparentemente fpeaks puede llegar a consumir muchos recursos, para solucionar eso.
#Se baja el sample rate, pero con el cuidado de tener en cuenta las frecuencias
#presentes en el audio. #ATENCIÓN: La salida es una matriz de cada pico, su amplitud y su frecuencia.
derrape.fpeaks <- fpeaks(derrape.spec, plot = TRUE)
derrape.fpeaks
df <- data.frame(frequency = p@freq, normalize = p@normalize)
df
p
dfreq(derrape, plot=TRUE)
plot(derrape.per)
#FRECUENCIA DOMINANTE: el audio principal, (nos puede servir para poder aislarla)
derrape.per
df <- data.frame(frequency = p@freq, normalize = p@width)
df
df <- data.frame(frequency = p@freq, normalize = p@spec)
df
max(p@spec)
df <- data.frame(frequency = p@freq, spec = p@spec)
df
plot(df)
plot(df, name="ALGO")
plot(df, main="ALGO")
df
#Frecuenciad dominante puede ser útil: dfreq(), sirve para algo parecido, pero toma un wave
dfreq(derrape, plot=TRUE)
library(seewave)
library(tuneR)
#Examen
#Primer Audio
audio1 <- readWave(file.choose())
audio1
audio2 <- readWave(file.choose()) #1C
#Obtenemos la Amplitud
spec1 <- spec(audio1, plot=FALSE)
spec2 <- spec(audio2, plot=FALSE)
spec1
#OBTENEMOS LA AMPLITUD
amp1 <- amplitude(audio1, plot=FALSE)
#OBTENEMOS LA AMPLITUD
amp1 <- amplitude(audio1, plot=FALSE)
library(seewave)
#OBTENEMOS LA AMPLITUD
amp1 <- amplitude(audio1, plot=FALSE)
library("seewave")
#OBTENEMOS LA AMPLITUD
spec1 <- spec(audio1, amplitude = TRUE, plot = FALSE)
spec2 <- spec(audio2, amplitude = TRUE, plot = FALSE)
plot(spec1$spec, main="Espectrograma de audio1")
par(mfrow = c(2, 2))
plot(spec1$spec, main="Espectrograma de audio1")
par(mfrow = c(2, 2))
plot(spec1$spec, main = "Espectrograma de audio1")
spec1.spec <- spec1$spec
plot(spec1$amp$x, spec1$amp$y, type = "l", xlab = "Tiempo (s)", ylab = "Amplitud", main = "Amplitud de audio1")
plot(spec2$amp$x, spec2$amp$y, type = "l", xlab = "Tiempo (s)", ylab = "Amplitud", main = "Amplitud de audio2")
audio1.per <- periodogram(audio1)
audio2.per <- periodogram(audio2)
plot(audio1.per, main="Periodograma audio1")
plot(audio2.per, main="Periodograma audio2")
plot(audio1.per, main="Periodograma audio1(1B)")
plot(audio2.per, main="Periodograma audio2(1C)")
#Comparación de Spectrogramas
par(mfrow= c(1, 2))
spec(audio1, main="Audio1 (1B)")
spec(audio2, main="Audio2 (1C)")
#Frecuencia fundamental y armónicos
audio1.autoc <- autoc(audio1, main="Autoc Audio1 (1B)")
audio2.autoc <- autoc(audio2, main="Autoc Audio2(1C)")
write.csv(audio1.autoc, file="audio1_autoc.csv")
write.csv(audio2.autoc, file="audio2_autoc.csv")
datos_audio1 <-read.csv("audio1_autoc.csv")
datos_audio2 <-read.csv("audio2_autoc.csv")
datos_audio1
datos_audio1 <-read.csv("audio1_autoc.csv")
datos_audio2 <-read.csv("audio2_autoc.csv")
nota_fundamental_audio1 <- min(datos_audio1$x)
nota_fundamental_audio2 <- min(datos_audio1$yx)
nota_fundamental_audio2 <- min(datos_audio1$x)
nota_fundamental_audio1
nota_fundamental_audio2
nota_fundamental_audio1 <- min(datos_audio1$y)
nota_fundamental_audio2 <- min(datos_audio1$y)
nota_fundamental_audio1
nota_fundamental_audio2
nota_fundamental_audio1 <- min(datos_audio1$y)
nota_fundamental_audio2 <- min(datos_audio2$y)
nota_fundamental_audio1
nota_fundamental_audio2
datos_audio1 <-read.csv("audio1_autoc.csv")
datos_audio2 <-read.csv("audio2_autoc.csv")
nota_fundamental_audio1 <- min(datos_audio1$y)
nota_fundamental_audio2 <- min(datos_audio2$y)
nota_fundamental_audio1
nota_fundamental_audio2
#Obtener Armónicos
n1 <- nrow(datos_audio1)
n2 <- nrow(datos_audio2)
nota_max1 <-max(datos_audio1$y)
nota_max2 <-max(datos_audio2$y)
nota_max1
nota_max2
audio <- readWave(file.choose())
audio.per <- periodogram(audio)
plot(audio.per, main="Periodograma Audio")
audio <- readWave(file.choose())
audio.per <- periodogram(audio)
plot(audio.per, main="Periodograma Audio")
install.packages("huffmancodeR")
install.packages("huffmancodeR")
audio.bark <- ffilter(audio, from = 8000, 9200, bandpass = TRUE, output="Wave")
audio.bark <- ffilter(audio, from = 8000, to=9200, bandpass = TRUE, output="Wave")
audio.bark.per <- periodogram(audio.bark, main="Periodograma Audio Bark")
#Comparación de Spectrogramas
par(mfrow= c(1, 2))
spec(audio1, main="Audio1 (1B)")
spec(audio2, main="Audio2 (1C)")
library("seewave")
library("seewave")
library("tuneR")
update.packages("tuneR")
audio <- readWave(file.choose())
audio
audio <- readWave(file.choose())
audio.periodogram <- periodogram(audio)
plot(audio, main="Periodogram Audio-Derrape")
audio <- readWave(file.choose())
audio.periodogram <- periodogram(audio)
plot(audio, main="Periodogram Audio-Derrape")
audio
audio.periodogram <- periodogram(audio)
plot(audio, main="Periodogram Audio-Derrape")
audio_ejercicio <- readWave(file.choose())
audio_ejercicio
audio_ejercicio.periodogram <- periodogram(audio_ejercicio)
plot(audio_ejercicio.periodogram, main="Periodogram Audio-Fire")
audio_ejercicio.bark <- ffilter(audio_ejercicio, bandpass = TRUE, from=8000, to=9200)
plot(audio_ejercicio.bark, main="Periodogram audio-fire Bark")
audio_ejercicio.bark.periodogram <- periodogram(audio_ejercicio.bark)
plot(audio_ejercicio.bark, main="Periodogram audio-fire Bark")
plot(audio_ejercicio.bark.periodogram, main="Periodogram audio-fire Bark")
audio_ejercicio.bark <- ffilter(audio_ejercicio, bandpass = TRUE, from=8000, to=9200)
audio_ejercicio.bark <- ffilter(audio_ejercicio, bandpass = TRUE, from=8000, to=9200, output = "Wave")
audio_ejercicio.bark.periodogram <- periodogram(audio_ejercicio.bark)
plot(audio_ejercicio.bark.periodogram, main="Periodogram audio-fire Bark")
audio_ejercicio <- readWave(file.choose())
audio_ejercicio <- readWave(file.choose())
audio_ejercicio
audio_ejercicio.periodogram <- periodogram(audio_ejercicio)
plot(audio_ejercicio.periodogram, main="Periodogram Audio-Fire")
audio_ejercicio <- readWave(file.choose())
audio_ejercicio.periodogram <- periodogram(audio_ejercicio)
plot(audio_ejercicio.periodogram, main="Periodogram Audio-Fire")
audio_ejercicio.periodogram <- periodogram(audio_ejercicio)
plot(audio_ejercicio.periodogram, main="Periodogram Audio-Derrape")
audio_ejercicio.bark <- ffilter(audio_ejercicio, bandpass = TRUE, from=8000, to=9200, output = "Wave")
audio_ejercicio.bark.periodogram <- periodogram(audio_ejercicio.bark)
plot(audio_ejercicio.bark.periodogram, main="Periodogram audio-fire Bark")
plot(audio_ejercicio.bark.periodogram, main="Periodogram audio-Derrape Bark")
#AHORA SI LO DE INDICES
#USAMOS SPEC, PORQUE ES UNA COSA DE COSAS ESTADÍSTICAS
tren <- readWave(file.choose())
camion <- readWave(file.choose())
#SPEC O MEANSPEC.
tren.spec <- spec(tren)
camion <- spec(camion)
#SPEC O MEANSPEC.
tren.spec <- spec(tren, main="Spec Tren")
camion <- spec(camion, main="Spec Camión")
tren.cut <- cutw(tren, from=0, to=10)
tren.cut <- cutw(tren, from=0, to=3)
camion.cut <- cutw(camion, from=0, to=3)
install.packages(tuneR)
install.packages("tuneR")
install.packages("seewave")
ks.dist(night.mspec, day.mspec)
library("seewave")
install.packages("seewave")
library("seewave")
install.packages("seewave")
install.packages("tuneR")
library(seewave)
tren <- readWave(file.choose())
tren
tren.spec <- spec(tren, main="Spec Tren")
#Información Mutua
#Entropía espectral y temporal?
# Comparamos 2 audios y mientras menos se empaten más información obtenemos
#symba() <--- lo que nos intereca es su complemento so:
#res <- 1 - symba(audio.spec, audio2.spec)$I
library("seewave")
library("tuneR")
derrape.spec <- spec(derrape, main="Spec Derrape")
tren.spec <- spec(tren, main="Spec Tren")
derrape.cut <- cutw(derrape, from=0, to=3)
tren.cut <- cutw(tren, from=0, to=3)
derrape.spec <- spec(derrape, main="Spec Derrape")
tren.spec <- spec(tren, main="Spec Tren")
res <- 1 - symba(derrape.spec, tren.spec)
derrape.spec <- spec(derrape.cut, main="Spec Derrape")
tren.spec <- spec(tren.cut, main="Spec Tren")
derrape.cut <- cutw(derrape, from=0, to=3, output = "Wave")
tren.cut <- cutw(tren, from=0, to=3, output = "Wave")
derrape.spec <- spec(derrape.cut, main="Spec Derrape")
tren.spec <- spec(tren.cut, main="Spec Tren")
res <- 1 - symba(derrape.spec, tren.spec)
derrape.cut
tren.cut
res <- 1 - symba(derrape.spec, tren.spec)$I
res <- (1 - symba(derrape.spec, tren.spec)$I)
res <- (1 - symba(tren.spec, tren.spec)$I)
library("tuneR")
library(tuneR)
#Información Mutua
#Entropía espectral y temporal?
# Comparamos 2 audios y mientras menos se empaten más información obtenemos
#symba() <--- lo que nos intereca es su complemento so:
#res <- 1 - symba(audio.spec, audio2.spec)$I
library("seewave")
library("tuneR")
#Información Mutua
#Entropía espectral y temporal?
# Comparamos 2 audios y mientras menos se empaten más información obtenemos
#symba() <--- lo que nos intereca es su complemento so:
#res <- 1 - symba(audio.spec, audio2.spec)$I
library("seewave")
library("tuneR")
plot(derrape.spec)
#Terminando indices beta
#100 - simspec(audio1.spec, audio2.spec)
100 - simspec(derrape.spec, audio2.spec)
#Terminando indices beta
#100 - simspec(audio1.spec, audio2.spec)
100 - simspec(derrape.spec, tren.spec)
derrape.cut <- cutw(derrape, from=0, to=3, output = "Wave")
tren.cut <- cutw(tren, from=0, to=3, output = "Wave")
derrape.cut
tren.cut
derrape.spec <- spec(derrape.cut, main="Spec Derrape")
tren.spec <- spec(tren.cut, main="Spec Tren")
res <- (1 - symba(tren.spec, derrape.spec)$I)#CON EL MISMO AUDIO FUNCIONA ESA MIERDA
derrape.spec.cut <- spec(derrape.cut, main="Spec Derrape")
tren.spec.cut <- spec(tren.cut, main="Spec Tren")
res <- (1 - symba(tren.spec, derrape.spec)$I)#CON EL MISMO AUDIO FUNCIONA ESA MIERDA
#Terminando indices beta
#100 - simspec(audio1.spec, audio2.spec)
100 - simspec(derrape.spec, tren.spec)
#Correlación entre espectros de frecuenca o algo así envento similar= cosa similar
sqrt(1-cor(derrape.spec.cut[,2] / sum(fire.spec.cut[,2])))
#Correlación entre espectros de frecuenca o algo así envento similar= cosa similar
sqrt(1-cor(derrape.spec.cut[,2] / sum(tren.spec.cut[,2])))
derrape.spec.cut <- spec(derrape.cut, main="Spec Derrape")
tren.spec.cut <- spec(tren.cut, main="Spec Tren")
res <- (1 - symba(tren.spec.cut, derrape.spec.cut)$I)#CON EL MISMO AUDIO FUNCIONA ESA MIERDA
#indice de disimilaridad temporal
#diffenv(day@left, day@right, f=day.samp_rate)
diffenv(derrape, tren)
#indice de disimilaridad temporal
#diffenv(day@left, day@right, f=day.samp_rate)
diffenv(derrape.cut, tren.cut)
derrape.cut
tren.cut
derrape.downsampled -> downsample(derrape.cut, samp.rate = 11025)
derrape.downsampled -> downsample(derrape.cut, samp.rate = 11025)
library("seewave")
derrape.downsampled -> downsample(derrape.cut, samp.rate = 11025)
derrape.downsampled <- downsample(derrape.cut, samp.rate = 11025)
derrape.downsampled
tren.cut
diffenv(derrape.downsampled, tren.cut)
tren.cut.sample.rate
tren.cut.sample_rate
tren.cut@samp.rate
derrape.cut <- downsample(derrape.cut, tren.cut@samp.rate)
derrape.cut
tren.cut
derrape.spec.cut <- spec(derrape.cut, main="Spec Derrape", overlap=512)
derrape.spec.cut <- spec(derrape.cut, main="Spec Derrape")
tren.spec.cut <- spec(tren.cut, main="Spec Tren")
res <- (1 - symba(tren.spec.cut, derrape.spec.cut)$I)#CON EL MISMO AUDIO FUNCIONA ESA MIERDA
res
res <- 1 - (symba(tren.spec.cut, derrape.spec.cut)$I)
res
#log-spectral distance
#logspec.dist(nigth.spec, day.mspec) ESTO DA EN EL EJEMPLO: 76.72
logspec.dist((derrape.spec.cut, tren.spec.cut))
#log-spectral distance
#logspec.dist(nigth.spec, day.mspec) ESTO DA EN EL EJEMPLO: 76.72
logspec.dist(derrape.spec.cut, tren.spec.cut)
#Terminando indices beta
#100 - simspec(audio1.spec, audio2.spec, PMF = TRUE) EL PMF es la cosa acumulada
100 - simspec(derrape.spec, tren.spec)
#Terminando indices beta
#100 - simspec(audio1.spec, audio2.spec, PMF = TRUE) EL PMF es la cosa acumulada
100 - simspec(derrape.spec.cut, tren.spec.cut)
#Correlación entre espectros de frecuenca o algo así envento similar= cosa similar  <1 es correlación negativa
sqrt(1-cor(derrape.spec.cut[,2] / sum(derrape.spec.cut[,2]), tren.spec.cut[,2]/ sum(tren.spec.cut[,2])))
#indice de disimilaridad temporal
#diffenv(day@left, day@right, f=day.samp_rate)
diffenv(derrape.cut, tren.cut)
install.packages("soundecology")
#bioacustic_index
#Biodiversidad acustica entre 2000 y 8000 Hz
#La forma de eso se parece a periodogram
#No es de seewave, es de soundecology
#EN MONO
#frecuencias de 2000 a 8000
#bioacustic_index(audio, min_freq=2000, max_freq=8000)
bioacustic_index(tren, min_freq=2000, max_freq=8000)
#cap 16 del libro
#bioacustic_index
#Biodiversidad acustica entre 2000 y 8000 Hz
#La forma de eso se parece a periodogram
#No es de seewave, es de soundecology
#EN MONO
#frecuencias de 2000 a 8000
#bioacustic_index(audio, min_freq=2000, max_freq=8000)
bioacustic_index(tren, min_freq=2000, max_freq=8000)
#cap 16 del libro
#bioacustic_index
#Biodiversidad acustica entre 2000 y 8000 Hz
#La forma de eso se parece a periodogram
#No es de seewave, es de soundecology
#EN MONO
#frecuencias de 2000 a 8000
#bioacustic_index(audio, min_freq=2000, max_freq=8000)
bioacoustic_index(tren, min_freq=2000, max_freq=8000)
library("soundecology")
#cap 16 del libro
#bioacustic_index
#Biodiversidad acustica entre 2000 y 8000 Hz
#La forma de eso se parece a periodogram
#No es de seewave, es de soundecology
#EN MONO
#frecuencias de 2000 a 8000
#bioacustic_index(audio, min_freq=2000, max_freq=8000)
bioacoustic_index(tren, min_freq=2000, max_freq=8000)
#cap 16 del libro
#bioacustic_index
#Biodiversidad acustica entre 2000 y 8000 Hz
#La forma de eso se parece a periodogram
#No es de seewave, es de soundecology
#EN MONO
#frecuencias de 2000 a 8000
#bioacustic_index(audio, min_freq=2000, max_freq=8000)
bioacoustic_index(derrape, min_freq=2000, max_freq=8000)
oldwd <- getwd()
oldwd
setwd("/home/alcss/Documentos/Programación/Clase/sonidos_ar/")
res<- AR(getwd(), datatype = "files")
library(seewave)
library(tuneR)
res<- AR(getwd(), datatype = "files")
res
library(tuneR)
library(seewave)
sh(derrape.spec, plot=FALSE)
sh(derrape.spec, plot=false)
sh(derrape.spec)
#SI QUEREMOS LA ENTROPÍA COMPLETA: MULTIPLICAMOS LA ESPECTRAL Y LA TEMPORAL
#ESO LO HACE LA FUNCIÓN H(wave)
#LA MULTIPLICACiÖN DE AMBAS MIERDAS ES LA ENTROPÍA NETA
#H()
H(derrape)
#ADI  //INDICE DE DIVERSIDAD ACÚSTICA
#TRABAJA EN UNA BANDA DE FRECUENCIAS DE 0-10
#TIENE CIERTO UMBRAL DE DECIBELIOS
#UTILIZA UN ARCHIVO: MONO WAVE
acoustic_diversity(derrape)
library(soundecology)
#ADI  //INDICE DE DIVERSIDAD ACÚSTICA
#TRABAJA EN UNA BANDA DE FRECUENCIAS DE 0-10
#APARENTEMENTE LAS DIVIDE
#TIENE CIERTO UMBRAL DE DECIBELIOS
#UTILIZA UN ARCHIVO: MONO WAVE
acoustic_diversity(derrape)
#ADI  //INDICE DE DIVERSIDAD ACÚSTICA
#TRABAJA EN UNA BANDA DE FRECUENCIAS DE 0-10
#APARENTEMENTE LAS DIVIDE
#TIENE CIERTO UMBRAL DE DECIBELIOS
#UTILIZA UN ARCHIVO: MONO WAVE
derrape.acoustic_diversity <-acoustic_diversity(derrape) #ESTA COSA DIO 1.9370
#Aparentemente barplot() sirve para graficar gráfica de barras
barplot(derrape.acoustic_diversity)
left<-derrape.acoustic_diversity$adi_left
right<-derrape.acoustic_diversity$adi_right
barplot(height = left, names=right, ylab="Proportion")
left
right
right<-derrape.acoustic_diversity$adi_right
right
#coeficiente ginny?
#Mide la desigualdad de una distribución
#indice ai //acoustic evenness index
#acoustic_evennes(forest)
#Síntesis aditiva
#coeficiente ginny?
#Mide la desigualdad de una distribución
#indice ai //acoustic evenness index
#acoustic_evennes(forest)
#Síntesis aditiva
#coeficiente ginny?
#Mide la desigualdad de una distribución
#indice ai //acoustic evenness index
#acoustic_evennes(forest)
library("seewave")
library("soundecology")
#Síntesis aditiva
#coeficiente ginny?
#Mide la desigualdad de una distribución
#indice ai //acoustic evenness index
acoustic_evennes(derrape)
#Síntesis aditiva
#coeficiente ginny?
#Mide la desigualdad de una distribución
#indice ai //acoustic evenness index
acoustic_evenness(derrape)
ACI(derrape)
#Biofónica vs antropofónica
#Los sintéticos no van en ninguno de los dos, es una categoría por si mismo
#Esta cosa no sirve para audios sintéticos (So: si es sintético: no se hace)
sdspec <- soundscapespec(derrape)
NDSI(sdspec)
